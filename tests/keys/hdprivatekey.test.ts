import { describe, expect, test, vi } from "vitest";
import HDPrivateKey from "../../src/keys/hdprivatekey";
import { InvalidB58Checksum, InvalidDerivationArgument, InvalidEntropyArgument, InvalidLength, InvalidNetwork, InvalidNetworkArgument, InvalidPath, NotEnoughEntropy, TooMuchEntropy } from "../../src/keys/exceptions";
import { networks } from "../../src/core/network/network-manager";
import HDKeyUtils from "../../src/keys/hdkey.utils";
import Base58Check from "../../src/encoding/base58check";
import BufferUtils from "../../src/utils/buffer.utils";

const xprivkey = 'F6rxzJdAfE9XecsrTeyXrcye1XYFbXHxs7iYWHvt2p1KwHKkmDVEcmFufzURFUTL5MbhuCNYDu2gTFkYexfPZq4BviayRVd2qjPS7BMtby7quzcV';
const json = '{"network":"mainnet","depth":0,"fingerPrint":876747070,"parentFingerPrint":0,"childIndex":0,"chainCode":"873dff81c02f525623fd1fe5167eac3a55a049de3d314bb42ee227ffed37d508","privateKey":"e8f32e723decf4051aefac8e2c93c9c5b214313817cdb01a1494b917c8436b35","checksum":-804831250,"xprivkey":"F6rxzJdAfE9XecsrTeyXrcye1XYFbXHxs7iYWHvt2p1KwHKkmDVEcmFufzURFUTL5MbhuCNYDu2gTFkYexfPZq4BviayRVd2qjPS7BMtby7quzcV"}';

describe('HDPrivate key interface', () => {
  const expectFail = (func: () => void, error: new (...args: any[]) => Error): void => {
    expect(() => func()).toThrow(error)
  };

  const expectDerivationFail = (argument: any, error: new (...args: any[]) => Error): void => {
    return expectFail(() => {
      let privateKey = new HDPrivateKey(xprivkey);
      privateKey.deriveChild(argument);
    }, error);
  };

  const expectFailBuilding = (argument: any, error: new (...args: any[]) => Error): void => {
    return expectFail(() => new HDPrivateKey(argument), error);
  };

  const expectSeedFail = (argument: any, error: new (...args: any[]) => Error): void => {
    return expectFail(() =>  HDPrivateKey.fromSeed(argument), error);
  };

  test('should make a new private key from random', () => {
    expect(new HDPrivateKey().xprivkey).toBeDefined();
  });

  test('should make a new private key from random for testnet', () => {
    let key = new HDPrivateKey('testnet');
    expect(key.xprivkey).toBeDefined();
    expect(key.network.name).toBe('testnet');
  });

  test('should error with an invalid checksum', () => {
    expectFailBuilding(xprivkey + '1', InvalidB58Checksum);
  });

  test('can be rebuilt from a json generated by itself', () => {
    let regenerate = new HDPrivateKey(json);
    expect(regenerate.xprivkey).toBe(xprivkey);
  });

  test('builds a json keeping the structure and same members', () => {
    expect(new HDPrivateKey(json).toJSON()).toEqual(new HDPrivateKey(xprivkey).toJSON());
  });

  describe('instantiation', () => {
    test('invalid argument: can not instantiate from a number', () => {
      expectFailBuilding(1, TypeError);
    });
    test('allows the use of a copy constructor', () => {
      expect(new HDPrivateKey(new HDPrivateKey(xprivkey)).xprivkey).toBe(xprivkey);
    });
  });

  describe('public key', () => {
    let testnetKey = new HDPrivateKey('tprv8ZgxMBicQKsPdEeU2KiGFnUgRGriMnQxrwrg6FWCBg4jeiidHRyCCdA357kfkZiGaXEapWZsGDKikeeEbvgXo3UmEdbEKNdQH9VXESmGuUK');
    let mainnetKey = new HDPrivateKey('F6rxzJdAfE9XecsrTdhujr5QDvdRafFS8T3F3GcfU7mvhGaJEeLCzeEfiEwe4FRV1Qm83nAGXCP9Cuk3rkF4WdAw6UhoXyh3gxnvFzfbFfJMqzKH');

    test('matches the network', () => {
      expect(testnetKey.publicKey.network).toEqual(networks.testnet);
      expect(mainnetKey.publicKey.network).toEqual(networks.mainnet);
    });

    test('cache for xpubkey works', () => {
      let privateKey = new HDPrivateKey(xprivkey);
      expect((privateKey as any)._hdPublicKey).not.toBeDefined();
      expect(privateKey.xpubkey).toBe(privateKey.xpubkey);
      expect((privateKey as any)._hdPublicKey).toBeDefined();
    });

  });

  test('inspect() displays correctly', () => {
    expect(new HDPrivateKey(xprivkey).inspect()).toBe('<HDPrivateKey: ' + xprivkey + '>');
  });
  test('fails when trying to derive with an invalid argument', () => {
    expectDerivationFail([], InvalidDerivationArgument);
  });

  test('catches early invalid paths', () => {
    expectDerivationFail('s', InvalidPath);
    expectDerivationFail(HDKeyUtils.Hardened*2, InvalidPath);
  });

  test('allows derivation of hardened keys by passing a very big number', () => {
    let privateKey = new HDPrivateKey(xprivkey);
    let derivedByNumber = privateKey.deriveChild(0x80000000);
    let derivedByArgument = privateKey.deriveChild(0, true);
    expect(derivedByNumber.xprivkey).toBe(derivedByArgument.xprivkey);
  });

  test('returns itself with \'m\' parameter', () => {
    let privateKey = new HDPrivateKey(xprivkey);
    expect(privateKey).toEqual(privateKey.deriveChild('m'));
  });

  test('returns InvalidArgument if invalid data is given to getSerializedError', () => {
    expect(HDKeyUtils.getSerializedError(1 as any, undefined, true) instanceof TypeError).toBe(true);
  });

  test('returns InvalidLength if data of invalid length is given to getSerializedError', () => {
    let b58s = Base58Check.encode(Buffer.from('onestring'));
    expect(HDKeyUtils.getSerializedError(b58s, undefined, true) instanceof InvalidLength).toBe(true);
  });

  test('returns InvalidNetworkArgument if an invalid network is provided', () => {
    expect(HDKeyUtils.getSerializedError(xprivkey, 'invalidNetwork', true) instanceof InvalidNetworkArgument).toBe(true);
  });

  test('recognizes that the wrong network was asked for', () => {
    expect(HDKeyUtils.getSerializedError(xprivkey, 'testnet', true) instanceof InvalidNetwork).toBe(true);
  });

  test('recognizes the correct network', () => {
    expect(HDKeyUtils.getSerializedError(xprivkey, 'livenet', true)).toBeNull();
  });

  describe('on creation from seed', () => {
    test('converts correctly from an hexa string', () => {
      expect(HDPrivateKey.fromSeed('01234567890abcdef01234567890abcdef').xprivkey).toBeDefined();
    });
    test('take default network on invalid network param', () => {
      expect(HDPrivateKey.fromSeed('01234567890abcdef01234567890abcdef', 'invalid').network).toEqual(networks.defaultNetwork);
    });
    test('fails when argument is not a buffer or string', () => {
      expectSeedFail(1, InvalidEntropyArgument);
    });
    test('fails when argument doesn\'t provide enough entropy', () => {
      expectSeedFail('01', NotEnoughEntropy);
    });
    test('fails when argument provides too much entropy', () => {
      let entropy = '0';
      for (let i = 0; i < 129; i++) {
        entropy += '1';
      }
      expectSeedFail(entropy, TooMuchEntropy);
    });
  });

  test('correctly errors if an invalid checksum is provided', () => {
    vi.spyOn(HDPrivateKey as any, '_buildFromSerialized').mockImplementation((key: any) => {
      let decoded = Base58Check.decode(key);
      let buffers = {
        version: decoded.subarray(HDKeyUtils.VersionStart, HDKeyUtils.VersionEnd),
        depth: decoded.subarray(HDKeyUtils.DepthStart, HDKeyUtils.DepthEnd),
        parentFingerPrint: decoded.subarray(HDKeyUtils.ParentFingerPrintStart, HDKeyUtils.ParentFingerPrintEnd),
        childIndex: decoded.subarray(HDKeyUtils.ChildIndexStart, HDKeyUtils.ChildIndexEnd),
        chainCode: decoded.subarray(HDKeyUtils.ChainCodeStart, HDKeyUtils.ChainCodeEnd),
        privateKey: decoded.subarray(HDKeyUtils.ChainCodeEnd+1, HDKeyUtils.ChainCodeEnd+1+32),
        checksum: Buffer.from([0,1,2,3]), // invalid checksum
      }
      return (HDPrivateKey as any)._buildFromBuffers(buffers);
    });

    expect(() => new HDPrivateKey(xprivkey)).toThrow(InvalidB58Checksum);
    
    vi.restoreAllMocks();
  });

  test("shouldn't matter if derivations are made with strings or numbers", () => {
    let privateKey = new HDPrivateKey(xprivkey);
    let derivedByString = privateKey.deriveChild("m/0'/1/2'");
    let derivedByNumber = privateKey.deriveChild(0, true).deriveChild(1).deriveChild(2, true);
    expect(derivedByNumber.xprivkey).toBe(derivedByString.xprivkey);
  });

  describe('validates paths', () => {
    test('validates correct paths', () => {
      let valid;

      valid = HDPrivateKey.isValidPath('m/0\'/1/2\'');
      expect(valid).toBe(true);

      valid = HDPrivateKey.isValidPath('m');
      expect(valid).toBe(true);

      valid = HDPrivateKey.isValidPath(123, true);
      expect(valid).toBe(true);

      valid = HDPrivateKey.isValidPath(123);
      expect(valid).toBe(true);

      valid = HDPrivateKey.isValidPath(HDKeyUtils.Hardened + 123);
      expect(valid).toBe(true);

      valid = HDPrivateKey.isValidPath(HDKeyUtils.Hardened + 123, true);
      expect(valid).toBe(true);

      valid = HDPrivateKey.isValidPath(undefined as any);
      expect(valid).toBe(false);
    });


    let invalid = [
      'm/-1/12',
      'bad path',
      'K',
      'm/',
      'm/12asd',
      'm/1/2//3',
    ];

    invalid.forEach(datum => {
      test('rejects illegal path ' + datum, () => {
        expect(HDPrivateKey.isValidPath(datum)).toBe(false);
        expect(HDKeyUtils.getDerivationIndexes(datum)).toBeNull();
      });
    });

    test('generates deriving indexes correctly', () => {
      let indexes;

      indexes = HDKeyUtils.getDerivationIndexes('m/-1/12');
      expect(indexes).toBeNull();

      indexes = HDKeyUtils.getDerivationIndexes('m/0/12/12\'');
      expect(indexes).toEqual([0, 12, HDKeyUtils.Hardened + 12]);
    });

  });

  describe('conversion to/from buffer', () => {
    test('should roundtrip to/from a buffer', () => {
      let priv = new HDPrivateKey(xprivkey);
      let toBuffer = priv.toBuffer();
      let fromBuffer = HDPrivateKey.fromBuffer(toBuffer);
      let roundTrip = new HDPrivateKey(fromBuffer.toBuffer());
      expect(roundTrip.xprivkey).toBe(xprivkey);
    });
  });

  describe('conversion to plain object/json', () => {
    let plainObject = JSON.parse(json);
    test('toObject leaves no Buffer instances', () => {
      let privKey = new HDPrivateKey(xprivkey);
      let object = privKey.toObject();
      Object.values(object).forEach(value => {
        expect(BufferUtils.isBuffer(value)).toBe(false);
      })
    });
    test('roundtrips toObject', () => {
      expect(HDPrivateKey.fromObject(new HDPrivateKey(xprivkey).toObject()).xprivkey).toBe(xprivkey);
    });
    test('roundtrips to JSON and to Object', () => {
      let privkey = new HDPrivateKey(xprivkey);
      expect(HDPrivateKey.fromObject(privkey.toJSON()).xprivkey).toBe(xprivkey);
    });
    test('recovers state from JSON string', () => {
      expect(new HDPrivateKey(JSON.stringify(plainObject)).xprivkey).toBe(xprivkey);
    });
    test('recovers state from Object', () => {
      expect(new HDPrivateKey(plainObject).xprivkey).toBe(xprivkey);
    });
  });
});
