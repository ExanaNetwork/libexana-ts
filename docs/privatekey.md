# Private Key

Represents a Nexa private key and is needed to be able to spend Nexa and sign transactions. See the official [Nexa Spec](https://spec.nexa.org/cryptography/keys/) for more information about private keys. A PrivateKey in libnexa-ts is an immutable object that has methods to import and export into a variety of formats including WIF (Wallet Import Format).

## Instantiate a Private Key

Here is how to create a new private key. It will generate a new random number `crypto` library.

```ts
let privateKey = new PrivateKey();

// Creates a private key from a hexa encoded number
let privateKey2 = PrivateKey.from('bb166827f219d47c1dfe96456b5002b306fee25ba58aac084ec1cb9f43b1707d');
```

To export and import a private key, you can do the following:

```ts
// encode into wallet export format
let exported = privateKey.toWIF();

// instantiate from the exported (and saved) private key
let imported = PrivateKey.fromWIF('6HZk5zTRZ144PtVa7bGfu6d3SPDf8kxN51U9xqYa2oQtwRKu3fxj');
```

Note: The WIF (Wallet Import Format) includes information about the network and if the associated public key is compressed or uncompressed (thus the same Nexa address will be generated by using this format).

To generate an Address or PublicKey from a PrivateKey:

```ts
let publicKey = privateKey.toPublicKey();
// or use getter accessor:
let publicKey = privateKey.publicKey;

let address = Address.fromPublicKey(publicKey, Networks.mainnet);
// or 
let address = privateKey.toAddress();
```

## Validating a Private Key

The code to do these validations looks like this:

```javascript
// validate an input, can be multiple formats. checkout API reference.
if (PrivateKey.isValid(input)){
  ...
}

// get the specific validation error that can occurred
let error = PrivateKey.getValidationError(input, Networks.mainnet);
if (error) {
  // handle the error
}
```

## API Reference
- [PrivateKey](api/classes/PrivateKey.md)